package com.ey.advisory.common.async;

import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.scheduling.support.CronExpression;
import org.springframework.stereotype.Component;

import com.ey.advisory.common.AppException;
import com.ey.advisory.common.ErrMsgEnhancementStrategy;
import com.ey.advisory.core.async.DefaultAsyncJobsService;
import com.ey.advisory.core.async.JobStatusConstants;
import com.ey.advisory.core.async.domain.master.AsyncExecJob;
import com.ey.advisory.core.async.domain.master.PeriodicExecJob;
import com.ey.advisory.core.async.repositories.master.PeriodicExecJobRepository;

import net.javacrumbs.shedlock.spring.annotation.SchedulerLock;

@Component
public class DefaultPeriodicJobRunner implements PeriodicJobRunner {

	private static final Logger LOGGER = LoggerFactory
			.getLogger(DefaultPeriodicJobRunner.class);

	/**
	 * Usually, periodic jobs are not associated with a single group. In this 
	 * scenario, we use a constant string as the group name to indicate that
	 * these jobs were generated by a periodic job.
	 */
	private static final String PERIODIC_JOB_GROUP_NAME = "PERIODIC";
	
	@Autowired
	private PeriodicExecJobRepository periodicJobRepo;

	@Autowired
	private DefaultAsyncJobsService persistenceManager;	
	
	@Autowired
	private AsyncExecControlParams controlParams;

	@Override
	@Scheduled(initialDelay = 5000, fixedRateString = 
						"${async.scheduler.frequency}")
	@SchedulerLock(name="DefaultPeriodicTask",
			lockAtMostFor = "PT5M", lockAtLeastFor = "PT1M")
		public void runPeriodicJobs() {
		
		try {
			LOGGER.debug("periodic Job Triggered");
			// First check if AsyncExec is not suspended. If it's suspended,
			// then print the log and go back to sleep.
			if(controlParams.isSuspended()) {
				LOGGER.info("Periodic job runner suspended....");
				// Return without proceeding.
				return;
			}
		
			if (LOGGER.isInfoEnabled()) {
				LOGGER.info("Periodic job runner triggered....");
			}

			// This is the start time of the periodic job runner. This is 
			// very critical timestamp.
			Date jobsStDate =  new Date();
					
			// Get all the active and valid jobs from the repository.
			List<PeriodicExecJob> jobs = periodicJobRepo
					.findActiveAndValidPeriodicJobs(jobsStDate);
			
			// Evaluate all periodic jobs for execution readiness and gather
			// the results. The result of each job will contain informaton 
			// of whether the job is ready to be executed and the 
			// success/failure reason. AFter getting the eval results for all
			// success and failure entries, filter out all the failed ones 
			// and get the list of succeeded ones in a list.
			List<PeriodicJobEvalResult> eligibleResults = 
					jobs.stream()
						.map(job -> evalPeriodicJobForExec(job, jobsStDate))
						.filter(jobResult -> jobResult.isReady())
						.collect(Collectors.toCollection(ArrayList::new));	
						
			// Stop the process if there aren't any jobs to be scheduled.
			// There should be a table with the results of each periodic job
			// evaluation cycle where we store the cumulative results like
			// total number of active jobs encountered, the total number of 
			// jobs ready to be scheduled and the total number rejected.
			if (eligibleResults.size() == 0) {
				String errMsg = String.format(
						"There are no Periodic jobs available to Schedule. "
						+ "Going back to sleep...");
				LOGGER.warn(errMsg);
				return;
			}
			
			// Finally, corresponding to each periodic job that's ready to 
			// execute, post a new job.
			if(LOGGER.isInfoEnabled()) {
				String errMsg = String.format(
						"About to schedule actual jobs. No: of jobs to be "
						+ "scheduled = %d, Total No: of jobs = %d", 
						eligibleResults.size(), jobs.size());
				LOGGER.info(errMsg);
			}
			
			// Record all eligible jobs and update the details of the
			// corresponding periodic jobs.
			recordEligibleJobs(eligibleResults);
			
			if (LOGGER.isInfoEnabled()) {
				String msg = String.format("Periodic job runner cycle "
						+ "completed. TotalActiveJobs = %d, "
						+ "TotalScheduledJobs = %d", jobs.size(),
						eligibleResults.size());
				LOGGER.info(msg);
			}
		} catch (Exception ex) {
			
			String errMsg = String.format(
					"Error occured while scheduling the PeriodicJobs. "
					+ "Going back to sleep...");
			LOGGER.error(errMsg, ex);
			
			// Throw the App Exception here. If the exception obtained is
			// AppException, then propagate it. Otherwise, create a new
			// app exception. This particular constructor of the AppException
			// will extract the nested exception and attach the message to the
			// specified string. (This way the person who monitors the
			// EY_JOB_DETAILS database will come to know the root cause of the
			// exception).
			throw new AppException(ex,
					ErrMsgEnhancementStrategy.APPEND_FIRST_NON_APP_EXCEPTION);

		}

	}
	
	private PeriodicJobEvalResult evalPeriodicJobForExec(
			PeriodicExecJob job, Date evalDate) {
		
		// If the job is executing for the first time, then return true.
		if(isFirstTime(job)) {
				String msg = String.format("The PeriodicJob: %d is about to "
						+ "be executed for the very first time.", 
						job.getId());
			if(LOGGER.isDebugEnabled()) {				
				LOGGER.debug(msg);
			}
			return new PeriodicJobEvalResult(job, true, evalDate, msg, 
					createActualJobForPeriodicJob(job));			
		}
		
		// If the actual job previously posted by the period job is still
		// active, then return false.
		if(isLastPostedJobStillActive(job)) {
			
				String msg = String.format("The acutal job posted for the "
						+ "PeriodicJob: %d is not complete yet. "
						+ "Actual Job Id = %d. Skipping the creation of "
						+ "an actual job", 
						job.getId(), job.getLastPostedJobId());
			if(LOGGER.isDebugEnabled()) {				
				LOGGER.debug(msg);
			}			
			return new PeriodicJobEvalResult(job, false, evalDate, msg, null);
		}
		
		// if the cron scheduling string configured in the DB for the job is
		// invalid, then return false. But before returning, print the 
		// log message.
		if(!isSchedulingStrValid(job)) {
			String msg = String.format("Invalid scheduling cron "
					+ "string encountered for PeriodicJobId: '%d'. "
					+ "Configured String is: [%s]. Not scheduling the job", 
					job.getId(), job.getCronExpression());
			LOGGER.error(msg);
			return new PeriodicJobEvalResult(job, false, evalDate, msg, null);
		}
		
		// If the next scheduled time of the job according to the configured
		// cron expression happens to be before the current date/time, then
		// the job is ready to be executed.
		if(getNextScheduledTime(job).before(new Date())) {
			String msg = String.format("The PeriodicJob: %d is ready to "
						+ "be executed now. Adding to list of actual jobs "
						+ "to be scheduled", job.getId());
			if(LOGGER.isDebugEnabled()) {				
				LOGGER.debug(msg);
			}			
			return new PeriodicJobEvalResult(job, true, evalDate, msg, 
					createActualJobForPeriodicJob(job));
		}
		
		// Any other scenario, return false. 
		String msg = String.format("The PeriodicJobId: '%d' is not "
				+ "ready for scheduling", job.getId());
		LOGGER.error(msg);
		
		return new PeriodicJobEvalResult(job, false, evalDate, msg, null);
	}
	
	private boolean isSchedulingStrValid(PeriodicExecJob job) {
		return CronExpression.isValidExpression(
				job.getCronExpression());
	}
	
	private Date getNextScheduledTime(PeriodicExecJob job) {
		CronExpression cronGenerator = CronExpression.parse(job.getCronExpression());

		ZonedDateTime jobStartDateTime = ZonedDateTime.ofInstant(job.getJobstartDate().toInstant(),
				ZoneId.systemDefault());

		ZonedDateTime nextTime = cronGenerator.next(jobStartDateTime);

		return Date.from(nextTime.toInstant());

	}

	/**
	 * This method checks if a periodic job previously posted is still active.
	 * It checks ift he posted date 
	 * @param job
	 * @return
	 */
	private boolean isLastPostedJobStillActive(PeriodicExecJob job) {
		Date lastPostedDate = job.getLastPostedDate();
		Date lastCompletedDate = job.getJobCompletionDate();
		
		return lastPostedDate != null && (lastCompletedDate == null || 
				lastCompletedDate.before(lastPostedDate));
	}
	
	private boolean isFirstTime(PeriodicExecJob job) {
		return job.getLastPostedDate() == null;
	}
	
	
	private void recordEligibleJobs(
			List<PeriodicJobEvalResult> eligibleResults) {
	
		// Get all async job instances to be saved to the DB.
		List<AsyncExecJob> actualJobs = eligibleResults.stream()
					.map(result -> result.getActualJob())
					.collect(Collectors.toCollection(ArrayList::new));
		
		// Get all Periodic job instances to be updated with the id of 
		// the newly posted jobs.
		List<PeriodicExecJob> periodicJobs = eligibleResults.stream()
				.map(result -> result.getPeriodicExecJob())
				.collect(Collectors.toCollection(ArrayList::new));
	
		// Make all the insertions and updations within the same transaction.
		persistenceManager.createAsyncJobsAndUpdatePeriodicJobs(
				actualJobs, periodicJobs);
		
	}
	
	private AsyncExecJob createActualJobForPeriodicJob(
						PeriodicExecJob periodicJob) {
		AsyncExecJob job = new AsyncExecJob();
		job.setGroupCode(PERIODIC_JOB_GROUP_NAME);
		job.setJobCategory(periodicJob.getJobCategory());
		job.setStatus(JobStatusConstants.SUBMITTED);
		job.setMessage(periodicJob.getRefParams());
		job.setPeriodicJobId(job.getPeriodicJobId());
		job.setJobPriority(50L);
		job.setUserName("SYSTEM");
		job.setPeriodicJobId(periodicJob.getId());
		job.setParentId(null);
		job.setCreatedDate(new Date());
		return job;
	}
	
}

class PeriodicJobEvalResult {
	
	private PeriodicExecJob periodicExecJob;
	private boolean isReady;
	private String message;
	private Date evalDate; // To be used as scheduling date.
	private AsyncExecJob actualJob;
	
	public PeriodicJobEvalResult(PeriodicExecJob periodicExecJob, 
			boolean isReady, Date date, String message, 
			AsyncExecJob actualJob) {
		this.periodicExecJob = periodicExecJob;
		this.isReady = isReady;
		this.evalDate = date;
		this.message = message;
		this.actualJob = actualJob;
	}

	public PeriodicExecJob getPeriodicExecJob() {
		return periodicExecJob;
	}

	public boolean isReady() {
		return isReady;
	}

	public String getMessage() {
		return message;
	}

	public Date getEvalDate() {
		return evalDate;
	}
	
	public AsyncExecJob getActualJob() {
		return actualJob;
	}

	@Override
	public String toString() {
		return "PeriodicJobEvalResult [periodicExecJob=" + periodicExecJob
				+ ", isReady=" + isReady + ", evalDate=" + evalDate
				+ ", message=" + message + "]";
	}
	
	
}
