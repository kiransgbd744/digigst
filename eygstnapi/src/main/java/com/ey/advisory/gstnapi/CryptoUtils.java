package com.ey.advisory.gstnapi;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ey.advisory.common.APICryptoException;

public class CryptoUtils {

	private static final Logger LOGGER = LoggerFactory
			.getLogger(CryptoUtils.class);

	public static final String AES_TRANSFORMATION = "AES/ECB/PKCS5Padding";
	public static final String RSA_TRANSFORMATION = "RSA/ECB/PKCS1Padding";
	public static final String AES_ALGORITHM = "AES";
	public static final String CHARACTER_ENCODING = "UTF-8";
	public static final int ENC_BITS = 256;
	public static final String X509 = "X.509";

	/**
	 * Java Util Base64.Encoder is a thread safe class. So, we can share this
	 * instance where ever we encode a bytes to Base64 string.
	 */
	private static final Base64.Encoder BASE64ENCODER = Base64.getEncoder();

	/**
	 * Java Util Base64.Decoder is a thread safe class. So, we can share this
	 * instance where ever we decode an encoded string to bytes.
	 */
	private static final Base64.Decoder BASE64DECODER = Base64.getDecoder();

	/**
	 * Make the class non-instantiable.
	 */
	private CryptoUtils() {
	}

	private static Cipher createCipher(String algorithm) {
		try {
			return Cipher.getInstance(algorithm);
		} catch (Exception ex) {
			String msg = "Exception while instantiating "
					+ "Encrypt/Decrypt Ciphers";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	/**
	 * App key is a random 32 byte key generated by the GSP. This method
	 * generates a 32 byte key using the AES algorithm and encodes the key to
	 * Base64 format. This app key is later used for decrypting the session
	 * encrypted key (sek) sent to us by GSTN.
	 * 
	 * @return the Base 64 encoded App Key string.
	 */
	public static String generateAppKey() {
		try {
			KeyGenerator keygen = KeyGenerator.getInstance(AES_ALGORITHM);
			keygen.init(ENC_BITS);
			SecretKey appKey = keygen.generateKey();
			return BASE64ENCODER.encodeToString(appKey.getEncoded());
		} catch (Exception ex) {
			String msg = "Exception while generating  the App "
					+ "Key for OTP Request";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	/**
	 * The Encrypted App key should be sent as part of the request to GSTN, as
	 * part of the OTP request. This app key is encrypted with the GSTN public
	 * key. This method encrypts the app key with the GSTN public key and
	 * returns the Base 64 encoded string of this encrypted app key data.
	 * 
	 * @param appKey
	 *            The Base 64 encoded App Key string.
	 * @param gstnPubKey
	 *            The PublicKey object representing the public key of GSTN. This
	 *            is extracted from the GSTN public certificate data.
	 * @return The encrypted App Key as Base 64 encoded string.
	 * 
	 */
	public static String encryptAppKey(String appKey, PublicKey gstnPubKey) {
		try {
			Cipher cipher = createCipher(CryptoUtils.RSA_TRANSFORMATION);
			cipher.init(Cipher.ENCRYPT_MODE, gstnPubKey);
			byte[] encryptedByte = cipher.doFinal(BASE64DECODER.decode(appKey));
			return BASE64ENCODER.encodeToString(encryptedByte);
		} catch (Exception ex) {
			String msg = "Exception while encrypting "
					+ "the App Key for OTP request";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	/**
	 * This is a generic method that gets a data byte array as input, an
	 * encryption key as a byte array, the Cipher Algorithm and the Key
	 * Algorithm as inputs, performs the encryption using these parameters and
	 * returns the encrypted data as byte array.
	 * 
	 * @param input
	 *            the input data as byte array
	 * @param key
	 *            the encryption key as byte array
	 * @param cipherAlgo
	 *            the Cipher creation algorithm to be used
	 * @param keyAlgo
	 *            the cryptographic key algorithm to be used.
	 * 
	 * @return the encrypted data as a Base64 string.
	 */
	private static byte[] encryptData(byte[] input, // Input data to be
													// encrypted
			byte[] key, String cipherAlgo, String keyAlgo) {
		try {
			Cipher cipher = createCipher(cipherAlgo);
			SecretKeySpec sk = new SecretKeySpec(key, keyAlgo);
			cipher.init(Cipher.ENCRYPT_MODE, sk);
			return cipher.doFinal(input);
		} catch (Exception ex) {
			String msg = "Exception while encrypting the GSTN response";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	/**
	 * After getting the Auth Token from GSTN, we use this method for all PUT
	 * and POST methods, to encrypt the JSON to be sent in the HTTP body to
	 * GSTN. This method accepts an input JSON string and a Base64 encoded
	 * Session Key (which is usually stored somewhere within our infrastructure,
	 * like in REDIS or in the DB), performs the encryption of the input JSON
	 * and returns the encrypted JSON data as a Base 64 encoded string. This
	 * string can be directly used within the request body.
	 * 
	 * @param inputJson
	 *            The json that needs to be encrypted for sending as part of a
	 *            PUT or POST request.
	 * @param sk
	 *            The Session Key that we obtained as a result of the decryption
	 *            of SEK returned by GSTN as part of the response key. This is a
	 *            Base 64 encoded SK.
	 * 
	 * @return the encrypted JSON data in Base 64 encoded format.
	 */
	public static String encryptAPIReqData(String inputJson, String sk) {
		try {
			byte[] inputJsonBytes = BASE64ENCODER
					.encode(inputJson.getBytes(CHARACTER_ENCODING));
			byte[] skBytes = BASE64DECODER.decode(sk);
			byte[] encryptedData = encryptData(inputJsonBytes, skBytes,
					AES_TRANSFORMATION, AES_ALGORITHM);
			return BASE64ENCODER.encodeToString(encryptedData);
		} catch (Exception ex) {
			String msg = "Exception while encrypting the API ReqData";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	public static String encryptOtpReqData(String otp, String appKey) {
		try {
			byte[] otpBytes = otp.getBytes(CHARACTER_ENCODING);
			byte[] appKeyBytes = BASE64DECODER.decode(appKey);
			byte[] encryptedData = encryptData(otpBytes, appKeyBytes,
					AES_TRANSFORMATION, AES_ALGORITHM);
			return BASE64ENCODER.encodeToString(encryptedData);
		} catch (Exception ex) {
			String msg = "Exception while encrypting the OTP ReqData";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	/**
	 * This method creates a Message Authentication Code (MAC) from the
	 * specified data, using the specified key, so that GSTN can verify both the
	 * message authenticity and message integrity of the data sent.
	 * 
	 * @param data
	 * @param key
	 * @return
	 */
	public static String hmacSHA256(String data, String key) {
		try {
			byte[] base64Data = BASE64ENCODER
					.encode(data.getBytes(CHARACTER_ENCODING));
			byte[] keyBytes = BASE64DECODER.decode(key);
			SecretKeySpec secretKey = new SecretKeySpec(keyBytes, "HmacSHA256");
			Mac mac = Mac.getInstance("HmacSHA256");
			mac.init(secretKey);
			byte[] hmacData = mac.doFinal(base64Data);
			return new String(BASE64ENCODER.encode(hmacData));
		} catch (Exception ex) {
			String msg = "Exception while generating the hmac";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	/**
	 * This is a generic method that accepts an encrypted data as a byte array,
	 * the decryption key as byte array, the cipher algorithm and the key
	 * algorithm as inputs; performs the decryption and returns the byte array
	 * containing the decrypted bytes.
	 * 
	 * @param input
	 *            the encrypted data as byte array
	 * @param key
	 *            the key capable of decrypting the encrypte ddata.
	 * @param cipherAlgo
	 *            the cipher algorithm used
	 * @param keyAlgo
	 *            the Secret key algorithm used.
	 * 
	 * @return the decrypted data as byte array.
	 */
	private static byte[] decryptData(byte[] input, byte[] key,
			String cipherAlgo, String keyAlgo) {
		try {
			Cipher cipher = createCipher(cipherAlgo);
			SecretKeySpec sk = new SecretKeySpec(key, keyAlgo);
			cipher.init(Cipher.DECRYPT_MODE, sk);
			return cipher.doFinal(input);
		} catch (Exception ex) {
			String msg = "Exception while decrypting the GSTN response";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	/**
	 * When GSTN sends back the data to an API request, it encrypts this data
	 * with a random key generated for that request. It then encrypts this
	 * random key with the Session Key and includes this encrypted random key
	 * (REK) as part of the response. So, our responsibility is to first decrypt
	 * the REK using the session key and obtain the Un-encrypted random key (RK)
	 * using which we can decrypt the response. This method is responsible for
	 * doing this activity.
	 * 
	 * @param rek
	 *            the encrypted Random Key sent to us by GSTN.
	 * @param sk
	 *            the Session key that we have as part of our authentication
	 *            process with GSTN. (This is usually loaded from some storage
	 *            like REDIS or DB)
	 * 
	 * @return the decrypted RK as a Base 64 encoded string.
	 */
	public static String decryptRek(String rek, String sk) {
		byte[] rekBytes = BASE64DECODER.decode(rek);
		byte[] skBytes = BASE64DECODER.decode(sk);
		byte[] decryptedRk = decryptData(rekBytes, skBytes, AES_TRANSFORMATION,
				AES_ALGORITHM);
		return BASE64ENCODER.encodeToString(decryptedRk);
	}

	/**
	 * When GSTN sends back the data to an API request, it encrypts this data
	 * with a random key generated for that request. It then encrypts this
	 * random key with the Session Key and includes this encrypted random key
	 * (REK) as part of the response. So, our responsibility is to first decrypt
	 * the REK using the session key and obtain the Un-encrypted random key (RK)
	 * using which we can decrypt the response. This method is responsible for
	 * doing this activity.
	 * 
	 * @param rek
	 *            the encrypted Random Key sent to us by GSTN.
	 * @param sk
	 *            the Session key that we have as part of our authentication
	 *            process with GSTN. (This is usually loaded from some storage
	 *            like REDIS or DB)
	 * 
	 * @return the decrypted RK as a Base 64 encoded string.
	 */
	public static String decryptSek(String sek, String appKey) {
		byte[] sekBytes = BASE64DECODER.decode(sek);
		byte[] appKeyBytes = BASE64DECODER.decode(appKey);
		byte[] decryptedSk = decryptData(sekBytes, appKeyBytes,
				AES_TRANSFORMATION, AES_ALGORITHM);
		return BASE64ENCODER.encodeToString(decryptedSk);
	}

	public static String decryptResponseJson(String encRespJson, String rk) {
		byte[] encRespJsonBytes = BASE64DECODER.decode(encRespJson);
		byte[] rkBytes = BASE64DECODER.decode(rk);
		byte[] decryptedJson = decryptData(encRespJsonBytes, rkBytes,
				AES_TRANSFORMATION, AES_ALGORITHM);
		return new String(BASE64DECODER.decode(decryptedJson));

	}

	/**
	 * When GSTN sends back the data to an API request, it encrypts this data
	 * with a random key generated for that request. It then encrypts this
	 * random key with the Session Key and includes this encrypted random key
	 * (REK) as part of the response. So, our responsibility is to first decrypt
	 * the REK using the session key and obtain the Un-encrypted random key (RK)
	 * using which we can decrypt the response. Once we get the un-encrypted
	 * random key (RK), we use it to decrypt the encrypted response. This method
	 * does this decryption process.
	 * 
	 * 
	 * @param encRespJson
	 *            the encrypted JSON data.
	 * @param rk
	 *            the unencrypted random key (RK) as a Base 64 encoded string.
	 * 
	 * @return the decrypted JSON response String.
	 */

	public static String decryptResponseJson(String encRespJson, String rek,
			String sk) {
		byte[] rekBytes = BASE64DECODER.decode(rek);
		byte[] skBytes = BASE64DECODER.decode(sk);
		byte[] decryptedRkBytes = decryptData(rekBytes, skBytes,
				AES_TRANSFORMATION, AES_ALGORITHM);

		byte[] encRespJsonBytes = BASE64DECODER.decode(encRespJson);
		byte[] decryptedJson = decryptData(encRespJsonBytes, decryptedRkBytes,
				AES_TRANSFORMATION, AES_ALGORITHM);

		return new String(BASE64DECODER.decode(decryptedJson));

	}

	public static String encryptPassword(byte[] plaintext,
			PublicKey gstnPubKey) {
		try {
			Cipher cipher = createCipher(CryptoUtils.RSA_TRANSFORMATION);
			cipher.init(Cipher.ENCRYPT_MODE, gstnPubKey);
			byte[] encryptedByte = cipher.doFinal(plaintext);
			return new String(BASE64ENCODER.encode(encryptedByte));
		} catch (Exception ex) {
			String msg = "Exception while encrypting "
					+ "the Password for Public Auth Token request";
			LOGGER.error(msg, ex);
			throw new APICryptoException(msg, ex);
		}
	}

	public static String decryptPublicJsonResponse(String encRespJson) {
		return new String(BASE64DECODER.decode(encRespJson));
	}

	public static String hmacSHA256ForEvc(String data, byte[] key)
			throws NoSuchAlgorithmException, InvalidKeyException,
			IllegalStateException, UnsupportedEncodingException {
		SecretKeySpec secretKey = new SecretKeySpec(key, "HmacSHA256");
		Mac mac = Mac.getInstance("HmacSHA256");
		mac.init(secretKey);
		byte[] hmacData = mac.doFinal(data.getBytes("UTF-8"));
		return new String(BASE64ENCODER.encode(hmacData));
	}
	
	

}
